
# Correr o visualizar proyecto 
1- Para poder visualizar este proyecto de forma local utiliza git con los siguientes comandos.

`git clone https://github.com/Maximiliano-Santana/MrSnowManGlobe.git`

2- Entraremos al archivo que se clono e instala las dependencias 

`npm install`

3- Inicia el servidor local 

`npm run dev`

4- Una vez que el servidor esta abierto pon el url Local en tu navegador de preferencia 

`http//localhost...`

# Realizacion del proyecto y caso de estudio 

Estos fueron los pasos que segui para realizar mi proyecto con three js sin a base de las geometrias que three js trae consigo.

La idea del proyecto es hacer una esfera de nieve, la cual contendra dentro un pequeño mundo de nieve generado proceduralmente, particulas de nieve cayendo, generare nubes e el objetivo es hacerlo con una estetica  cartoon y atractiva.

## Inicio del modelado con figuras primitivas de three,js.

*Base* para crear la base donde estara la esfera estoy buscando una forma rectangular con biselado, hecha de madera oscura con barniz, ademas le pondre una placa dorada de letras con mi nombre en forma de firma.

Primero que nada para lograr obtener esa forma rectangular con biselado a partir de figuras primitivas de three.js tengo la opcion de utilizar ExtrudeGemetry.

*ExtrudeGeometry* es una geometria integrada con three.js la cual crea una geometria extruida a partir de una forma hecha por curvas. Al crear una instancia de esta geometria recibe 2 parametros:
    -shapes: Array: Recibe un objeto *Shape* o un arreglo de estos
    -options: object: Recibe un objeto que contenga the parametros de la geometria.
        `curveSegments`: Int que definte el numero de puntos en las curvas (default 12).
        `steps`: Int que define el numero de puntos utilizados para subdividir segmentos a lo largo de la extruccion hecha. (default 1).
        `depth`: Float Define la profundidad de la extruccion (default 1).
        `bevelEnabled`: Bool Activa el biselado (default true).
        `bevelThickness`: Float Que tan profundo en la forma original llega el biselado.
        `bevelSize`: Float Distancia desde el contorno de la forma hasta donde se extiende el biselado. (default 0.1).
        `bevelOffset`: Float Distancia desde la el contorno de la forma en la que empieza el biselado. (default 0)
        `bevelSegments` Int Numero de capas en el biseldo (default 3)
        `extrudePath`: THREE.Curve. 
        `UVGenerator`: Object Objeto que posee funciones para generar UVs.

Ahora que entiendo como funciona una geometria extruida y que es necesario pasarle una instancia de la clase *Shape* voy a profundizar mas en la creacion de estas. *Shape* es una clase hija de la clase *Path* que a su vez es hija de la clase *CurvePath* y esta a su ves es hija de la clase *Curve*, entonces para entender esto voy a indagar mas desde la base de todo esto.

*Curve* Es una clase abtracta base para crea un objecto *Curve* que contiene metodos para interplacion.
La interpolación es un proceso matemático que se utiliza para estimar valores desconocidos o faltantes entre dos o más puntos conocidos. Tiene la propiedad 
`.arcLengthDivisions` es un entero el cual determina la cantidad de divisiones al calular las longitudes con algunos metodos (Default es 200 Si la curva es muy larga se recomienda aumentarlo)
Algunos de sus metodos mas importantes son:
    `getPoint()` `getPointAt()`, reciben un numero del 0 al 1 el cual representa en que posicion de la curva se quiere obtener una posicion, entonces devolvera ese vector unor recibe u y el otro t.
    `.getPoints()`, `.getSpacedPoints()` recibe un entero que representa divisiones, el nupero de piezas que dividen la curva. Default es 5.
    `.getLength()` Devuelve la longitud total del arco de la curva.
    `.getLengths()` Devuleve una lista de distancias cumulativas divididas segun el entero que recibe.
    `.updateArcLengths()` Actualiza el cache de las distancias segmentadas cumulativas, este metodo deberia ser llamado cada vez que un parametro escambiado.
    `.getUtoTmapping()` Recibe un valor u en el rango del 0 al 1 y regresa el valor t,, los cuales son equidistantes al final de la curva y se pueden usar en los metodos getPoints.
    `.getTangent()` `getTangentAt()` Recibe un valor u y t al igual que los metodos getPoints devuelven un vector tangente a la curva segun el punto especificado por los valors u y t.
    `.clone()` `.copy()` Crea un clon de la instancia o copia otra curva en la instancia 
    `.toJSON()` `formJSON()` Devuelve y crea a partir de un formato JSON la informacion de la instancia.


*CurvePath* Es una clase abstracta base que ectiende a la clase *Curve*, es un arreglo o conjunto de curvas conectadas que mantienen los metodos de la clase *Curve*. Tiene la propiedad `.curves` que devuelve el arreglo de curvas por el que esta conformado y tiene el atributo `.autoClose` hara que que se cierre el punto final con el inicial automaticamente. Sus metodos son:
    `.add()` Recibe un objeto cuva y la agrega al arreglo de curvas 
    `.closePath()` para conectar el primer punto con el ultimo punto de la curva.
    `.getCurveLengths()` Devuelve una lista de las distancias cumulativas de las curvas dentro del areeglo .curves
    `getPoints()` `getSappcedPoints()` recibe un entero representa el numero de piezas en las que se divide la curva (default 12) y retorna un arreglo de puntos representando una secuencia de la curva. 

*Path* Es una representacion de trayectorias en 2D. La clase proporciona metodos para crear trayectorias y contornos de formas en 2D a partir de la manipulacion y crecion de puntos.
El constructor recibe un arreglo de ojetos *Vector2*, es de forma opcional ya que tambien se pueden crear trayectorias a partir de los metodos que estos posee y un *Path* vacio es creado, con un *Vector2* inicial en el origen (0, 0). Este path tiene la propiedad `.currentPoint`, cualquier curva nueva que se agregue empeazara en este punto, se refiere al ultimo punto agregado desde donde partira el siguiente puntos. Los metodos mas importantes son: 
    `arc()`y `ellipse()` añade una ElipseCurve posicionada relativamente al currentPoint. 
    `bezierCurveTo()` añade una curva bezier.
    `lineTo()` conecta una LineCurve al .currenPoint.
    `moveTo()` mueve el .currentPoint a la posicion indicada.
    `quadraticCurveTo()` crea una curva cuadratica desde el .currentPoint

*Shape* Define un plano de forma 2D arbitraria utilizando trayectorias con agujeros opcionales. Puede ser utilizado con *ExtrueGeometry* y *ShapeGeometry*, para obtener puntos o obtener caras trianguladas.
El constructor recibe puntos, un arreglo de Vector2 el cual es opcional, . Crea una forma a partir de puntos, el primer punto define el desplazamiento (offset), luego los puntos sucesivos se agregan al arreglo de curvas como Line Curves. Esta clas etiene algunas propiedades nuevas como `.uuid` un identificador unico compuesto por 125 bits generado aleatoriamente, no debe ser editado, tiene la propiedad `.holes` que es un array de *Paths* que define los agujeros en la forma. 
Y los metodos que esta tiene son heredados de todas las anteriores clases aprendidas por lo que podemos usar todos, admas posee un par de metodos extras.
`.extractPoints()` recibe un entero, el cual representa el numero de divisiones para que el acabado de la figura sea fino y el deseado. A su vez se puede utilizar el `getPoints()`, y regresaa un objeto con los puntos de la forma y de los agujeros 
